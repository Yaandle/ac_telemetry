#!/usr/bin/env python3
"""
Assetto Corsa Telemetry Terminal Analytics
Low-latency terminal-based data analysis using DuckDB Python library
"""

import sys
from pathlib import Path
import argparse
import plotly.graph_objects as go
from plotly.subplots import make_subplots

try:
    import duckdb
except ImportError:
    print("‚ùå Missing duckdb. Install with: pip install duckdb")
    sys.exit(1)

def format_lap_time(seconds):
    """Convert seconds to M:SS.ms format"""
    minutes = int(seconds // 60)
    remaining_seconds = seconds % 60
    return f"{minutes}:{remaining_seconds:06.3f}"

def analyze_session_summary(csv_path):
    """Quick session summary statistics"""
    print("\n" + "="*70)
    print("üìä SESSION SUMMARY")
    print("="*70)
    
    query = f"""
    SELECT 
        COUNT(*) as total_samples,
        MAX(current_lap) as total_laps,
        ROUND(MAX(speed_kmh), 2) as top_speed_kmh,
        ROUND(AVG(CASE WHEN speed_kmh > 5 THEN speed_kmh END), 2) as avg_speed_kmh,
        ROUND(MAX(lap_time_sec), 1) as session_duration_sec,
        ROUND(MAX(distance_m) / 1000, 2) as total_distance_km
    FROM read_csv_auto('{csv_path}')
    """
    
    print_query_results(query)

def analyze_lap_summary(csv_path):
    """Per-lap statistics pivot table"""
    print("\n" + "="*70)
    print("üìà LAP-BY-LAP STATISTICS")
    print("="*70)
    
    query = f"""
    SELECT 
        current_lap as lap,
        COUNT(*) as samples,
        ROUND(MAX(speed_kmh), 1) as top_speed,
        ROUND(AVG(CASE WHEN speed_kmh > 5 THEN speed_kmh END), 1) as avg_speed,
        ROUND(AVG(gas) * 100, 1) as avg_throttle_pct,
        ROUND(AVG(brake) * 100, 1) as avg_brake_pct,
        ROUND(MAX(lap_time_sec) - MIN(lap_time_sec), 3) as lap_duration_sec
    FROM read_csv_auto('{csv_path}')
    GROUP BY current_lap
    ORDER BY current_lap
    """
    
    print_query_results(query, format_time_columns=['lap_duration_sec'])

def analyze_speed_distribution(csv_path):
    """Speed distribution histogram"""
    print("\n" + "="*70)
    print("üìä SPEED DISTRIBUTION (Histogram)")
    print("="*70)
    
    query = f"""
    SELECT 
        FLOOR(speed_kmh / 10) * 10 as speed_range_kmh,
        COUNT(*) as frequency
    FROM read_csv_auto('{csv_path}')
    WHERE speed_kmh > 0
    GROUP BY FLOOR(speed_kmh / 10)
    ORDER BY speed_range_kmh
    """
    
    con = duckdb.connect()
    result = con.execute(query).fetchall()
    con.close()
    
    if result:
        max_freq = max(row[1] for row in result)
        print(f"{'Speed Range':>15} | {'Frequency':>10} | Distribution")
        print("-" * 70)
        for speed_range, freq in result:
            bar_length = int((freq / max_freq) * 40)
            bar = '‚ñà' * bar_length
            print(f"{int(speed_range):>4d}-{int(speed_range)+10:<3d} km/h | {freq:>10,} | {bar}")

def analyze_throttle_brake_correlation(csv_path):
    """Analyze throttle/brake patterns"""
    print("\n" + "="*70)
    print("üîÑ THROTTLE & BRAKE ANALYSIS")
    print("="*70)
    
    query = f"""
    SELECT 
        CASE 
            WHEN gas > 0.9 THEN 'Full Throttle (>90%)'
            WHEN gas > 0.5 THEN 'Partial Throttle (50-90%)'
            WHEN gas > 0 THEN 'Light Throttle (<50%)'
            ELSE 'Coasting'
        END as throttle_state,
        COUNT(*) as samples,
        ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (), 1) as percentage,
        ROUND(AVG(speed_kmh), 1) as avg_speed
    FROM read_csv_auto('{csv_path}')
    GROUP BY 1
    ORDER BY 2 DESC
    """
    
    print_query_results(query)
    
    print("\nBraking Analysis:")
    query = f"""
    SELECT 
        CASE 
            WHEN brake > 0.7 THEN 'Hard Braking (>70%)'
            WHEN brake > 0.3 THEN 'Medium Braking (30-70%)'
            WHEN brake > 0 THEN 'Light Braking (<30%)'
            ELSE 'No Braking'
        END as brake_state,
        COUNT(*) as samples,
        ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (), 1) as percentage,
        ROUND(AVG(speed_kmh), 1) as avg_speed
    FROM read_csv_auto('{csv_path}')
    GROUP BY 1
    ORDER BY 2 DESC
    """
    
    print_query_results(query)

def plot_speed_over_time_ascii(csv_path):
    """ASCII line graph of speed over time - full session range"""
    print("\n" + "="*100)
    print("üìà SPEED OVER TIME (ASCII Graph) - Full Session")
    print("="*100)
    
    # Get ALL data points from the entire session
    con = duckdb.connect()
    
    # First get total time range
    time_query = f"""
    SELECT 
        MIN(lap_time_sec) as min_time,
        MAX(lap_time_sec) as max_time,
        COUNT(*) as total_points
    FROM read_csv_auto('{csv_path}')
    """
    time_info = con.execute(time_query).fetchone()
    min_time, max_time, total_points = time_info
    
    # Sample evenly across the ENTIRE session
    sample_rate = max(1, total_points // 390)
    
    query = f"""
    WITH sampled_data AS (
        SELECT 
            ROW_NUMBER() OVER (ORDER BY lap_time_sec) as row_num,
            lap_time_sec,
            speed_kmh
        FROM read_csv_auto('{csv_path}')
    )
    SELECT 
        lap_time_sec,
        speed_kmh
    FROM sampled_data
    WHERE row_num % {sample_rate} = 0
    ORDER BY lap_time_sec
    LIMIT 390
    """
    
    data_points = con.execute(query).fetchall()
    con.close()
    
    if not data_points:
        print("No data to plot")
        return
    
    max_speed = max(row[1] for row in data_points)
    min_speed = 0
    
    height = 20
    width = 90
    
    print(f"\nSpeed (km/h) vs Time (seconds)")
    print(f"Max Speed: {max_speed:.0f} km/h | Session Duration: {max_time:.1f}s | Points: {len(data_points)}\n")
    
    # Plot points
    for h in range(height, -1, -1):
        speed_threshold = (h / height) * max_speed
        line = f"{speed_threshold:5.0f} ‚îÇ"
        
        for i in range(width):
            if i < len(data_points):
                _, speed = data_points[i]
                if abs(speed - speed_threshold) < (max_speed / height * 1.5):
                    line += "‚óè"
                else:
                    line += " "
            else:
                line += " "
        print(line)
    
    print("      ‚îî" + "‚îÄ" * width)
    print(f"       0s{' ' * (width-20)}~{max_time/2:.0f}s{' ' * 10}{max_time:.1f}s")


def analyze_gas_brake_by_lap(csv_path):
    """Average gas/brake usage per lap with visualization"""
    print("\n" + "="*70)
    print("üéÆ GAS & BRAKE USAGE BY LAP")
    print("="*70)
    print("Average Inputs Per Lap:")
    
    query = f"""
    SELECT 
        current_lap as lap,
        ROUND(AVG(gas) * 100, 1) as gas_pct,
        ROUND(AVG(brake) * 100, 1) as brake_pct
    FROM read_csv_auto('{csv_path}')
    GROUP BY current_lap
    ORDER BY current_lap
    """
    
    con = duckdb.connect()
    result = con.execute(query).fetchall()
    con.close()
    
    if not result:
        print("No results found")
        return
    
    print(f"{'Lap':>3} | {'Gas %':>6} | {'Brake %':>7} | Visualization")
    print("-" * 70)
    
    for lap, gas_pct, brake_pct in result:
        # Calculate bar lengths (out of 35 chars for gas, proportional for brake)
        gas_bar_len = int((gas_pct / 100) * 35)
        brake_bar_len = int((brake_pct / 100) * 35)
        
        gas_bar = '‚ñà' * gas_bar_len
        brake_bar = '‚ñë' * brake_bar_len
        
        print(f"{lap:>3} | {gas_pct:>5.1f}% | {brake_pct:>6.1f}% | G:{gas_bar:<35} B:{brake_bar}")

def plot_gas_brake_per_lap(csv_path, downsample_factor=1):
    """Plot gas and brake data for each lap with clean, simple design"""
    
    print("\n" + "="*100)
    print("üéÆ GAS & BRAKE USAGE PER LAP")
    print("="*100)
    
    con = duckdb.connect()
    
    # Get list of laps
    laps_query = f"""
    SELECT DISTINCT current_lap 
    FROM read_csv_auto('{csv_path}')
    ORDER BY current_lap
    """
    laps = [row[0] for row in con.execute(laps_query).fetchall()]
    
    # Create subplots - one per lap
    fig = make_subplots(
        rows=len(laps), 
        cols=1,
        subplot_titles=[f'Lap {lap}' for lap in laps],
        vertical_spacing=0.06
    )
    
    for idx, lap in enumerate(laps, 1):
        print(f"\nProcessing Lap {lap}...")
        
        # Fetch lap data
        query = f"""
        WITH lap_data AS (
            SELECT 
                ROW_NUMBER() OVER (ORDER BY lap_time_sec) as sample_point,
                CAST(gas AS DOUBLE) as gas,
                CAST(brake AS DOUBLE) as brake
            FROM read_csv_auto('{csv_path}', header=true)
            WHERE current_lap = {lap}
        )
        SELECT sample_point, gas, brake
        FROM lap_data
        WHERE sample_point % {downsample_factor} = 0
        ORDER BY sample_point
        """
        
        data_points = con.execute(query).fetchall()
        
        if not data_points:
            print(f"  ‚ö†Ô∏è  No data for Lap {lap}")
            continue
        
        sample_points = [d[0] for d in data_points]
        gas_values = [d[1] for d in data_points]
        brake_values = [d[2] for d in data_points]
        
        print(f"  ‚úì {len(data_points):,} data points loaded")
        
        # Gas trace
        fig.add_trace(
            go.Scatter(
                x=sample_points,
                y=gas_values,
                name='Gas',
                mode='lines',
                line=dict(color='#2ecc71', width=1.5),
                showlegend=(idx == 1),
                hovertemplate='Gas: %{y:.4f}<extra></extra>'
            ),
            row=idx, col=1
        )
        
        # Brake trace
        fig.add_trace(
            go.Scatter(
                x=sample_points,
                y=brake_values,
                name='Brake',
                mode='lines',
                line=dict(color='#e74c3c', width=1.5),
                showlegend=(idx == 1),
                hovertemplate='Brake: %{y:.4f}<extra></extra>'
            ),
            row=idx, col=1
        )
        
        # Update axes with more precision
        fig.update_xaxes(
            title_text="Time", 
            row=idx, col=1,
            showgrid=True,
            gridcolor='rgba(200, 200, 200, 0.2)',
            zeroline=False
        )
        fig.update_yaxes(
            title_text="Input", 
            row=idx, col=1, 
            range=[0, 1],
            dtick=0.1,  # Show every 0.1 (10%)
            showgrid=True,
            gridcolor='rgba(200, 200, 200, 0.2)',
            zeroline=True
        )
    
    # Update layout with minimal clean design
    fig.update_layout(
        height=400 * len(laps),
        title={
            'text': "Gas & Brake Analysis",
            'font': {'size': 20, 'color': '#2c3e50'}
        },
        showlegend=True,
        legend=dict(
            x=1.02, 
            y=1,
            bgcolor='rgba(255, 255, 255, 0.95)',
            bordercolor='rgba(0, 0, 0, 0.1)',
            borderwidth=1
        ),
        margin=dict(t=80, b=60, l=80, r=140),
        plot_bgcolor='white',
        paper_bgcolor='white',
        font=dict(family='system-ui, -apple-system, sans-serif', size=11, color='#2c3e50'),
        hovermode='x unified'
    )
    
    # Save with high quality settings
    output_file = 'gas_brake_analysis.html'
    fig.write_html(
        output_file,
        config={
            'displayModeBar': True,
            'displaylogo': False,
            'modeBarButtonsToRemove': ['lasso2d', 'select2d'],
            'toImageButtonOptions': {
                'format': 'png',
                'width': 1920,
                'height': 1080,
                'scale': 2
            }
        }
    )
    
    print(f"\n{'‚îÄ'*100}")
    print(f"‚úÖ Analysis complete!")
    print(f"üìä Total laps: {len(laps)}")
    print(f"üíæ Saved to: {output_file}")
    print(f"üéØ Downsample factor: {downsample_factor}")
    print("="*100 + "\n")
    
    fig.show()
    con.close()

def print_query_results(query, format_time_columns=None):
    """Execute DuckDB query and print results in formatted table"""
    con = duckdb.connect()
    result = con.execute(query)
    
    # Get column names
    columns = [desc[0] for desc in result.description]
    rows = result.fetchall()
    con.close()
    
    if not rows:
        print("No results found")
        return
    
    format_time_columns = format_time_columns or []
    
    # Calculate column widths
    col_widths = []
    for i, col in enumerate(columns):
        max_width = len(col)
        for row in rows:
            if col in format_time_columns:
                val_width = len(format_lap_time(row[i]))
            else:
                val_width = len(str(row[i]))
            max_width = max(max_width, val_width)
        col_widths.append(max_width + 2)
    
    # Print header
    header = "‚îÇ".join(f"{col:^{col_widths[i]}}" for i, col in enumerate(columns))
    separator = "‚îÄ".join("‚îÄ" * w for w in col_widths)
    
    print("‚îå" + separator + "‚îê")
    print("‚îÇ" + header + "‚îÇ")
    print("‚îú" + separator + "‚î§")
    
    # Print rows
    for row in rows:
        formatted_row = []
        for i, val in enumerate(row):
            if columns[i] in format_time_columns:
                formatted_row.append(f"{format_lap_time(val):>{col_widths[i]}}")
            elif isinstance(val, float):
                formatted_row.append(f"{val:>{col_widths[i]}.2f}")
            else:
                formatted_row.append(f"{str(val):>{col_widths[i]}}")
        print("‚îÇ" + "‚îÇ".join(formatted_row) + "‚îÇ")
    
    print("‚îî" + separator + "‚îò")

def main():
    parser = argparse.ArgumentParser(
        description='Analyze Assetto Corsa telemetry data in the terminal'
    )
    parser.add_argument('csv_file', help='Path to telemetry CSV file')
    
    args = parser.parse_args()
    
    csv_path = Path(args.csv_file)
    if not csv_path.exists():
        print(f"‚ùå File not found: {csv_path}")
        sys.exit(1)
    
    # Run all analyses
    analyze_session_summary(csv_path)
    analyze_lap_summary(csv_path)
    
    analyze_throttle_brake_correlation(csv_path)
    
    plot_speed_over_time_ascii(csv_path)
    analyze_speed_distribution(csv_path)
    analyze_gas_brake_by_lap(csv_path)
    plot_gas_brake_per_lap(csv_path)

if __name__ == "__main__":
    main()
